
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>å¥å­æ’åˆ—éŠæˆ²</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "pinyin-pro": "https://esm.sh/pinyin-pro@3.7.0",
        "lodash/shuffle": "https://esm.sh/lodash.shuffle@4.2.0",
        "sortablejs": "https://esm.sh/sortablejs@1.15.0"
      }
    }
  </script>
</head>
<body class="bg-sky-50">
  <div id="root" class="p-6 max-w-3xl mx-auto"></div>

  <script type="module">
    import React, { useState, useEffect } from 'react';
    import { createRoot } from 'react-dom/client';
    import { pinyin, customPinyin } from 'pinyin-pro';
    import shuffle from 'lodash/shuffle';
    import Sortable from 'sortablejs';
 
    
    


    const CUSTOM_PINYIN_HANS = {
  çˆ¸çˆ¸: 'bÃ ba',
  å­: 'zi',
  å¦ˆå¦ˆ: 'mÄma',
  å§å§: 'jiÄ›jie',
  å¦¹å¦¹: 'mÃ¨imei',
  é¥ºå­: 'jiÇozi',
  å¥¶å¥¶: 'nÇinai',
  çˆ·çˆ·: 'yÃ©ye',
  å¼Ÿå¼Ÿ: 'dÃ¬di',
  å“¥å“¥: 'gÄ“ge',
  å”å”: 'shÅ«shu',
  å–œæ¬¢: 'xÇhuan',   // â† ç°¡é«”
  æ—©ä¸Š: 'zÇoshang', 
  æ™šä¸Š: 'wÇnshang',
  ä»¬: 'men',
};

const CUSTOM_PINYIN_HANT = {
  çˆ¸çˆ¸: 'bÃ ba',
  å­: 'zi',
  åª½åª½: 'mÄma',
  å§å§: 'jiÄ›jie',
  å¦¹å¦¹: 'mÃ¨imei',
  é¤ƒå­: 'jiÇozi',
  å¥¶å¥¶: 'nÇinai',
  çˆºçˆº: 'yÃ©ye',
  å¼Ÿå¼Ÿ: 'dÃ¬di',
  å“¥å“¥: 'gÄ“ge',
  å”å”: 'shÅ«shu', // â† ç¹é«”
  å€‘: 'men',
};
      const zhuyinFallback = {
      æˆ‘: 'ã„¨ã„›Ë‡',
      æ˜¯: 'ã„•Ë‹',
      è€å¸«: 'ã„Œã„ Ë‡ ã„•',
      å­¸ç”Ÿ: 'ã„’ã„©ã„ËŠ ã„•ã„¥',
    };

    function Game() {
      const [lang, setLang] = useState('zh-Hant');
      const [voice, setVoice] = useState(null);
      const [availableVoices, setAvailableVoices] = useState([]);
      const [questions, setQuestions] = useState([]);
      const [originalQuestions, setOriginalQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [mode, setMode] = useState('pinyin');
      const [gameStarted, setGameStarted] = useState(false);
      const [startTime, setStartTime] = useState(null);
      const [elapsed, setElapsed] = useState(0);
      const [errorCount, setErrorCount] = useState(0);
      const [correctCount, setCorrectCount] = useState(0);
      const [finished, setFinished] = useState(false);
      const [inputRaw, setInputRaw] = useState('ä»–/ä¸æ˜¯/å­©å­\næˆ‘/æ˜¯/è€å¸«\næˆ‘/æ˜¯/å­¸ç”Ÿ');
      const [zhuyinCache, setZhuyinCache] = useState({});
      const [pendingVoiceName, setPendingVoiceName] = useState(null);
      const hasStartedRef = React.useRef(false);
      const parsedCurrent = questions[currentIndex];
      const texts = {
    'labelLanguage': { 'zh-Hant': 'èªè¨€', 'zh-Hans': 'è¯­è¨€' },
    'labelVoice':    { 'zh-Hant': 'èªéŸ³', 'zh-Hans': 'è¯­éŸ³' },
    'start': { 'zh-Hant': 'é–‹å§‹éŠæˆ²', 'zh-Hans': 'å¼€å§‹æ¸¸æˆ' },
    'title': { 'zh-Hant': 'å¥å­æ’åˆ— ğŸ¥ğŸ¥ğŸ¥', 'zh-Hans': 'å¥å­æ’åˆ— ğŸ¥ğŸ¥ğŸ¥' },
    'completed': { 'zh-Hant': 'ğŸ‰ å…¨éƒ¨å®Œæˆï¼', 'zh-Hans': 'ğŸ‰ å…¨éƒ¨å®Œæˆï¼' },
    'totalTime': { 'zh-Hant': 'ç¸½æ™‚é–“', 'zh-Hans': 'æ€»æ—¶é—´' },
    'questionsDone': { 'zh-Hant': 'å®Œæˆé¡Œæ•¸', 'zh-Hans': 'å®Œæˆé¢˜æ•°' },
    'errors': { 'zh-Hant': 'éŒ¯èª¤æ¬¡æ•¸', 'zh-Hans': 'é”™è¯¯æ¬¡æ•°' },
    'replay': { 'zh-Hant': 'å†ç©ä¸€æ¬¡', 'zh-Hans': 'å†ç©ä¸€æ¬¡' },
    'share': { 'zh-Hant': 'åˆ†äº«éŠæˆ²', 'zh-Hans': 'åˆ†äº«æ¸¸æˆ' },
    'timeAndError': { 'zh-Hant': 'æ™‚é–“', 'zh-Hans': 'æ—¶é—´' },
    'errorCount': { 'zh-Hant': 'éŒ¯èª¤', 'zh-Hans': 'é”™è¯¯' },
    'questionPrefix': { 'zh-Hant': 'ç¬¬', 'zh-Hans': 'ç¬¬' },
    'questionSuffix': { 'zh-Hant': 'é¡Œ', 'zh-Hans': 'é¢˜' },
    'totalPrefix': { 'zh-Hant': 'å…±', 'zh-Hans': 'å…±' },
    'totalSuffix': { 'zh-Hant': 'é¡Œ', 'zh-Hans': 'é¢˜' },

  };

  useEffect(() => {
  if (lang === 'zh-Hans') {
    customPinyin(CUSTOM_PINYIN_HANS);
  } else {
    customPinyin(CUSTOM_PINYIN_HANT);
  }
  // é€™è£¡ä¸éœ€è¦åšå…¶ä»–äº‹ï¼Œä¹‹å¾Œ pinyin() æœƒç”¨æœ€æ–°çš„è¦å‰‡
}, [lang]);

       useEffect(() => {
  const updateVoices = () => {
    const voices = window.speechSynthesis.getVoices();
    const chineseVoices = voices.filter(v => v.lang.startsWith('zh'));
    setAvailableVoices(chineseVoices);

    // 1) åˆ†äº«é€£çµæœ‰æŒ‡å®šèªéŸ³åç¨± â†’ å„ªå…ˆé¸
    if (pendingVoiceName) {
      const matched = chineseVoices.find(v => v.name === pendingVoiceName);
      if (matched) {
        setVoice(matched);
        setPendingVoiceName(null); // ç”¨å®Œå°±æ¸…æ‰
        return;
      }
    }

    // 2) æ²’æœ‰æŒ‡å®šæˆ–æ‰¾ä¸åˆ° â†’ æ²’æœ‰é¸éæ™‚æ‰çµ¦é è¨­
    if (!voice && chineseVoices.length > 0) {
      setVoice(chineseVoices[0]);
    }
  };

  updateVoices();
  window.speechSynthesis.onvoiceschanged = updateVoices;
}, [pendingVoiceName]);  // â† åŠ ä¸Šä¾è³´ï¼Œè®“ pendingVoiceName æ”¹è®Šæ™‚å¯å†å˜—è©¦ä¸€æ¬¡


      function speak(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      if (voice) {
       utterance.voice = voice;
       utterance.lang = voice.lang || (lang === 'zh-Hant' ? 'zh-TW' : 'zh-CN');
     } else {
       utterance.lang = lang === 'zh-Hant' ? 'zh-TW' : 'zh-CN';
     }
     speechSynthesis.cancel();
     setTimeout(() => speechSynthesis.speak(utterance), 0);
  }


      const generateShareLink = () => {
      const payload = {
        questions,                 // ç›®å‰çš„äº‚åºé¡Œç›®ï¼ˆç…§ä½ ç•¶å‰çœ‹åˆ°çš„é †åºï¼‰
        lang,                      // éŠæˆ²èªè¨€ zh-Hant / zh-Hans
        mode,                      // pinyin / zhuyin
        voiceName: voice?.name || null,  // ä½¿ç”¨è€…é¸çš„èªéŸ³åç¨±ï¼ˆå¦‚æœæ‰¾ä¸åˆ°å°±çµ¦ nullï¼‰
    };

       const url = `${window.location.origin}${window.location.pathname}?q=${encodeURIComponent(JSON.stringify(payload))}`;
        navigator.clipboard.writeText(url).then(() => alert('åˆ†äº«é€£çµå·²è¤‡è£½ï¼'));
     };


      useEffect(() => {
  const params = new URLSearchParams(window.location.search);
  const encoded = params.get('q');
  if (!encoded) return;

  try {
    const parsed = JSON.parse(decodeURIComponent(encoded));

    // æ–°æ ¼å¼ï¼šåŒ…å« questions/lang/mode/voiceName
    if (parsed && typeof parsed === 'object' && Array.isArray(parsed.questions)) {
      setQuestions(parsed.questions);           // ç”¨åˆ†äº«æ™‚çš„ã€Œäº‚åºå¾Œé¡Œç›®ã€
      setOriginalQuestions(parsed.questions);   // é‡ç©æ™‚ç¶­æŒåŒä¸€çµ„é¡Œåº«ï¼ˆæœƒå†æ´—ç‰Œï¼‰
      if (parsed.lang) setLang(parsed.lang);
      if (parsed.mode) setMode(parsed.mode);
      if (parsed.voiceName) setPendingVoiceName(parsed.voiceName);
    } else if (Array.isArray(parsed)) {
      // èˆŠæ ¼å¼ç›¸å®¹ï¼šåªæœ‰åŸå§‹é¡Œåº«ï¼ˆé–‹å•Ÿæ™‚ä»æœƒç”¨åŸå§‹é †åºï¼‰
      setQuestions(parsed);
      setOriginalQuestions(parsed);
    }

    setGameStarted(true);
    hasStartedRef.current = false;
    setStartTime(null);
    setElapsed(0);
    setErrorCount(0);
    setCorrectCount(0);
    setCurrentIndex(0);
    setFinished(false);
  } catch (err) {
    console.error('è¼‰å…¥åˆ†äº«é¡Œåº«å¤±æ•—', err);
  }
}, []);


      useEffect(() => {
        let timer;
        if (gameStarted && startTime && !finished) {
          timer = setInterval(() => {
            setElapsed(Math.floor((Date.now() - startTime) / 1000));
          }, 1000);
        }
        return () => {
          if (timer) clearInterval(timer);
        };
      }, [gameStarted, startTime, finished]);

      useEffect(() => {
       const current = questions[currentIndex] || [];
       if (!current.length) return;
        const optionZone = document.getElementById('option-zone');
        const answerZone = document.getElementById('answer-zone');

       optionZone.innerHTML = '';
       answerZone.innerHTML = '';
       const oldOpt = Sortable.get(optionZone);
       if (oldOpt) oldOpt.destroy();
       const oldAns = Sortable.get(answerZone);
       if (oldAns) oldAns.destroy();

       const zhuyinOverrides = {
       'çˆºçˆºå’Œ': 'ã„§ã„ËŠ ã„§ã„Ë™ ã„ã„œËŠ',
        'çˆºçˆº': 'ã„§ã„ËŠ ã„§ã„Ë™ ',
       'çˆ¸çˆ¸': 'ã„…ã„šË‹ ã„…ã„šË™',
       'åª½åª½': 'ã„‡ã„šË™ ã„‡ã„š',
       'æˆ‘': 'ã„¨ã„›Ë‡',
       };


       if (mode === 'zhuyin') {
       current.forEach(word => {
         if (!zhuyinCache[word]) {
          if (zhuyinOverrides[word]) {
           setZhuyinCache(prev => ({ ...prev, [word]: zhuyinOverrides[word] }));
           return;
        }

      // âœ… å…ˆè©¦æ•´å€‹è©æŸ¥è©¢
      fetch(`https://www.moedict.tw/uni/${encodeURIComponent(word)}.json`)
        .then(res => res.json())
        .then(data => {
          const raw = data?.heteronyms?.[0]?.bopomofo || '';
          const isValid = /^[\u3100-\u312F\u02CA\u02C7\u02CB\u02D9\s]+$/.test(raw);
          if (isValid) {
            setZhuyinCache(prev => ({ ...prev, [word]: raw }));
          } else {
            // â— æ•´å€‹è©æŸ¥ä¸åˆ° â†’ æ”¹ç”¨é€å­—æŸ¥è©¢
            const chars = [...word];
            const promises = chars.map(char =>
              fetch(`https://www.moedict.tw/uni/${encodeURIComponent(char)}.json`)
                .then(res => res.json())
                .then(cdata => cdata?.heteronyms?.[0]?.bopomofo || '[ç„¡]')
                .catch(() => '[éŒ¯èª¤]')
            );

            Promise.all(promises).then(results => {
              const combined = results.join(' ');
              setZhuyinCache(prev => ({ ...prev, [word]: combined }));
            });
          }
        })
        .catch(() => {
          setZhuyinCache(prev => ({ ...prev, [word]: '[éŒ¯èª¤]' }));
        });
    }
  });
}

        shuffle(current).forEach(word => {
          const div = document.createElement('div');
          div.className = 'w-[90px] p-2 border rounded bg-white text-center shadow cursor-pointer';
          div.setAttribute('data-word', word);
          // å»é™¤ onclick ä»¥å…çˆ†è²
          div.innerHTML = `
            <div class="word font-bold">${word}</div>
            <div class="text-xs text-gray-600">${mode === 'pinyin' ? pinyin(word, { toneType: 'mark' }) : (zhuyinCache[word] || 'æŸ¥è©¢ä¸­...')}</div>
          `;
          optionZone.appendChild(div);
        });

        Sortable.create(optionZone, {
          group: 'shared',
          animation: 150,
          sort: false,
         onChoose: (evt) => {
           if (!hasStartedRef.current) {
              hasStartedRef.current = true;
              setStartTime(Date.now());
          }
           const dragged = evt.item?.getAttribute('data-word');
           if (dragged) speak(dragged);
        }

        });

        optionZone.addEventListener('click', () => {
        if (!hasStartedRef.current) {
           hasStartedRef.current = true;
           setStartTime(Date.now());
        }
      }, { once: true });


        Sortable.create(answerZone, {
          group: 'shared',
          animation: 150,
          onStart: () => {
           if (!hasStartedRef.current) {
            hasStartedRef.current = true;
            setStartTime(Date.now());
          }
      },

          onSort: () => {
            setTimeout(() => {
              const order = Array.from(answerZone.children).map(div =>
                div.getAttribute('data-word')
              );
              const correct = current;
              const match = JSON.stringify(order) === JSON.stringify(correct);

              if (match && order.length === correct.length) {   
                setCorrectCount(c => c + 1);
                if (currentIndex + 1 === questions.length) {
                  setFinished(true);
                  new Audio('https://www.soundjay.com/human/sounds/applause-8.mp3').play();
                } else {
                  setCurrentIndex(i => i + 1);
                }
              } else if (order.length === correct.length) {
                new Audio('https://www.myinstants.com/media/sounds/error.mp3').play();
                setErrorCount(c => c + 1);
                const wrongTiles = Array.from(answerZone.children);
                wrongTiles.forEach(tile => optionZone.appendChild(tile));
              }
            }, 0);
          }
        });

      }, [questions, currentIndex, mode, zhuyinCache, voice, lang]);

      const parseInput = () => {
        const lines = inputRaw.split('\n').map(line => line.trim()).filter(Boolean);
        const parsed = lines.map(line => line.split('/').map(s => s.trim()));
        const shuffled = shuffle(parsed);
       setQuestions(shuffled);
       setOriginalQuestions(parsed); // ä¿ç•™åŸå§‹é †åºï¼ˆç”¨æ–¼é‡ç©ï¼‰
       setGameStarted(true);
       setElapsed(0);
       setErrorCount(0);
       setCorrectCount(0);
       setCurrentIndex(0);
       setFinished(false);
};

      return (
        React.createElement('div', null,
        React.createElement('p', { className: 'text-left text-xl font-bold text-gray-800 mb-4 leading-relaxed' }, texts.title[lang]),
        React.createElement('div', { className: 'mb-4' },
        React.createElement('label', { className: 'mr-2' }, `${texts.labelLanguage[lang]}ï¼š`),
        React.createElement('select', {
        value: lang,
        onChange: e => setLang(e.target.value),
       className: 'border px-2 py-1 rounded'
     },
       React.createElement('option', { value: 'zh-Hant' }, 'ç¹é«”ä¸­æ–‡'),
       React.createElement('option', { value: 'zh-Hans' }, 'ç®€ä½“ä¸­æ–‡')
     
  ),
  
 // èªéŸ³ä¸‹æ‹‰é¸å–®é–‹å§‹
  availableVoices.length > 0 && React.createElement('div', { className: 'mt-2' },
    React.createElement('label', { className: 'mr-2' }, `${texts.labelVoice[lang]}ï¼š`),
    React.createElement('select', {
      value: voice?.name,
      onChange: e => {
        const selected = availableVoices.find(v => v.name === e.target.value);
        setVoice(selected);
      },
      className: 'border px-2 py-1 rounded'
    },
      ...availableVoices.map(v =>
        React.createElement('option', { key: v.name, value: v.name },
          `${v.name} (${v.lang})`
        )
      )
    )
  )
  // èªéŸ³ä¸‹æ‹‰é¸å–®çµæŸ
),
  
  
  
          !gameStarted ? (
            React.createElement('div', null,
              React.createElement('h1', { className: 'text-xl font-bold text-gray-700 mb-2' }, 'è¼¸å…¥é¡Œç›®ï¼ˆæ¯è¡Œä¸€é¡Œï¼Œç”¨ / æ–·å¥ï¼‰'),
              React.createElement('textarea', {
                className: 'w-full h-40 p-2 border rounded',
                placeholder: 'ä¾‹å¦‚ï¼šæˆ‘/æ˜¯/è€å¸«',
                value: inputRaw,
                onChange: e => setInputRaw(e.target.value)
              }),
              React.createElement('button', {
                onClick: parseInput,
                className: 'mt-4 px-4 py-2 bg-blue-600 text-white rounded'
              }, texts.start[lang])
            )
          ) : finished ? (
            React.createElement('div', { className: 'text-center' },
              React.createElement('h2', { className: 'text-2xl font-bold mb-2' }, texts.completed[lang]),
              React.createElement('p', null, `${texts.totalTime[lang]}ï¼š${elapsed} ç§’`),
              React.createElement('p', null, `${texts.questionsDone[lang]}ï¼š${correctCount}`),
              React.createElement('p', null, `${texts.errors[lang]}ï¼š${errorCount}`),
              React.createElement('div', { className: 'flex justify-center gap-2 mt-4' },
                React.createElement('button', {
                  className: 'px-4 py-2 bg-blue-600 text-white rounded',
                  onClick: () => {
                  const shuffled = shuffle(originalQuestions);
                  setQuestions(shuffled);
                  setCurrentIndex(0);
                  setCorrectCount(0);
                  setErrorCount(0);
                  hasStartedRef.current = false;
                  setStartTime(null);
                  setElapsed(0);
                  setFinished(false);
                }

                }, texts.replay[lang]),
                React.createElement('button', {
                  className: 'px-4 py-2 bg-green-600 text-white rounded',
                  onClick: generateShareLink
                }, texts.share[lang])
              )
            )
          ) : (
            React.createElement('div', null,
              React.createElement('div', { className: 'mb-2 flex justify-between' },
                React.createElement('span', null,
  `${texts.questionPrefix[lang]} ${currentIndex + 1} ${texts.questionSuffix[lang]} / ` +
  `${texts.totalPrefix[lang]} ${questions.length} ${texts.totalSuffix[lang]}`
),
                React.createElement('button', {
                  onClick: () => setMode(mode === 'pinyin' ? 'zhuyin' : 'pinyin'),
                  className: 'text-sm px-2 py-1 border rounded bg-green-100'
                }, `${mode === 'pinyin' ? 'æ³¨éŸ³ãƒ¢ãƒ¼ãƒ‰ã«å¤‰æ›´' : 'æ‹¼éŸ³ãƒ¢ãƒ¼ãƒ‰ã«å¤‰æ›´'}`)
              ),
              React.createElement('div', { className: 'grid grid-cols-1 gap-4' },
                React.createElement('div', null,
                  React.createElement('h3', { className: 'text-sm mb-1 text-gray-600' },),
                  React.createElement('div', {
                    id: 'option-zone',
                    className: 'min-h-[80px] flex flex-wrap gap-2 border p-2 bg-rose-100 rounded'
                  })
                ),
                React.createElement('div', null,
                  React.createElement('h3', { className: 'text-sm mb-1 text-gray-600' }, 'æ–‡ã‚’æ­£ã—ã„é †ç•ªã«ä¸¦ã¹ã¦ãã ã•ã„ã€‚'),
                  React.createElement('div', {
                    id: 'answer-zone',
                    className: 'min-h-[80px] flex flex-wrap gap-2 border p-2 bg-white rounded'
                  })
                )
              ),
              React.createElement('div', { className: 'mt-4 text-sm text-gray-600' },
                 `${texts.timeAndError[lang]}ï¼š${elapsed}sã€€${texts.errorCount[lang]}ï¼š${errorCount}`
              )
            )
          )
        )
      );
    }

    const root = createRoot(document.getElementById('root'));
    root.render(React.createElement(Game));
  </script>
</body>
</html>
